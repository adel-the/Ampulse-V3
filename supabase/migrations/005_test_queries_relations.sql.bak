-- ====================================
-- REQUÊTES DE TEST POUR VÉRIFIER LES RELATIONS
-- SoliReserve Enhanced - Tests de relations et fonctionnalités
-- ====================================

-- ====================================
-- 1. TESTS DE RELATIONS PRINCIPALES
-- ====================================

-- Test 1: Relation Hotels -> Rooms -> Reservations
SELECT 
    'Hotel-Room-Reservation Chain' as test_name,
    h.nom as hotel_name,
    COUNT(DISTINCT r.id) as total_rooms,
    COUNT(DISTINCT res.id) as total_reservations,
    COUNT(DISTINCT CASE WHEN r.statut = 'occupee' THEN r.id END) as occupied_rooms,
    ROUND(h.taux_occupation, 2) as calculated_rate
FROM public.hotels h
LEFT JOIN public.rooms r ON h.id = r.hotel_id
LEFT JOIN public.reservations res ON r.id = res.chambre_id
WHERE h.statut = 'ACTIF'
GROUP BY h.id, h.nom, h.taux_occupation
ORDER BY h.nom;

-- Test 2: Relation Operateurs -> Conventions -> Reservations
SELECT 
    'Operator-Convention-Reservation Chain' as test_name,
    op.organisation as operator_name,
    COUNT(DISTINCT conv.id) as conventions_count,
    COUNT(DISTINCT res.id) as reservations_count,
    COALESCE(SUM(res.prix * res.duree), 0) as total_revenue
FROM public.operateurs_sociaux op
LEFT JOIN public.conventions_prix conv ON op.id = conv.operateur_id
LEFT JOIN public.reservations res ON op.id = res.operateur_id
WHERE op.statut = 'actif'
GROUP BY op.id, op.organisation
ORDER BY total_revenue DESC;

-- Test 3: Relation Clients/Usagers -> Reservations
SELECT 
    'Client-Reservation Relationship' as test_name,
    c.nom || ' ' || c.prenom as client_name,
    COUNT(res.id) as reservation_count,
    MIN(res.date_arrivee) as first_reservation,
    MAX(res.date_depart) as last_reservation,
    array_agg(DISTINCT res.statut) as reservation_statuses
FROM public.clients c
LEFT JOIN public.usagers u ON c.nom = u.nom AND c.prenom = u.prenom
LEFT JOIN public.reservations res ON u.id = res.usager_id
GROUP BY c.id, c.nom, c.prenom
HAVING COUNT(res.id) > 0
ORDER BY reservation_count DESC;

-- ====================================
-- 2. TESTS DE COHÉRENCE DES DONNÉES
-- ====================================

-- Test 4: Vérification des prix dans les conventions vs réservations
SELECT 
    'Price Consistency Check' as test_name,
    h.nom as hotel_name,
    op.organisation as operator_name,
    conv.type_chambre,
    conv.prix_conventionne as convention_price,
    AVG(res.prix) as average_reservation_price,
    COUNT(res.id) as reservations_using_convention
FROM public.conventions_prix conv
JOIN public.hotels h ON conv.hotel_id = h.id
JOIN public.operateurs_sociaux op ON conv.operateur_id = op.id
LEFT JOIN public.reservations res ON conv.operateur_id = res.operateur_id 
    AND conv.hotel_id = res.hotel_id
WHERE conv.statut = 'active'
    AND res.date_arrivee >= conv.date_debut
    AND (conv.date_fin IS NULL OR res.date_arrivee <= conv.date_fin)
GROUP BY h.nom, op.organisation, conv.type_chambre, conv.prix_conventionne
HAVING COUNT(res.id) > 0
ORDER BY h.nom, op.organisation;

-- Test 5: Vérification de la cohérence des statuts de chambres
SELECT 
    'Room Status Consistency' as test_name,
    h.nom as hotel_name,
    r.numero as room_number,
    r.statut as room_status,
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM public.reservations res 
            WHERE res.chambre_id = r.id 
            AND res.statut = 'EN_COURS'
            AND CURRENT_DATE BETWEEN res.date_arrivee AND res.date_depart
        ) THEN 'Should be occupied'
        ELSE 'Status seems correct'
    END as status_check
FROM public.rooms r
JOIN public.hotels h ON r.hotel_id = h.id
WHERE h.statut = 'ACTIF'
ORDER BY h.nom, r.numero;

-- ====================================
-- 3. TESTS DE PERFORMANCE DES REQUÊTES MÉTIER
-- ====================================

-- Test 6: Requête de disponibilité des chambres (simulation booking)
EXPLAIN (ANALYZE, BUFFERS) 
SELECT 
    h.nom as hotel_name,
    r.numero as room_number,
    r.type as room_type,
    r.prix as price,
    rc.name as category_name
FROM public.rooms r
JOIN public.hotels h ON r.hotel_id = h.id
LEFT JOIN public.room_categories rc ON r.category_id = rc.id
WHERE h.statut = 'ACTIF' 
    AND r.statut = 'disponible'
    AND h.ville = 'Paris'
    AND NOT EXISTS (
        SELECT 1 FROM public.reservations res
        WHERE res.chambre_id = r.id
        AND res.statut IN ('CONFIRMEE', 'EN_COURS')
        AND '2024-09-01'::DATE <= res.date_depart
        AND '2024-09-10'::DATE >= res.date_arrivee
    )
ORDER BY r.prix, r.numero;

-- Test 7: Requête de tableau de bord (dashboard)
EXPLAIN (ANALYZE, BUFFERS)
SELECT 
    h.nom as hotel_name,
    h.chambres_total,
    h.chambres_occupees,
    h.taux_occupation,
    COUNT(DISTINCT res_actives.id) as active_reservations,
    COUNT(DISTINCT res_futures.id) as future_reservations,
    COALESCE(SUM(res_actives.prix), 0) as current_daily_revenue
FROM public.hotels h
LEFT JOIN public.reservations res_actives ON h.id = res_actives.hotel_id
    AND res_actives.statut = 'EN_COURS'
    AND CURRENT_DATE BETWEEN res_actives.date_arrivee AND res_actives.date_depart
LEFT JOIN public.reservations res_futures ON h.id = res_futures.hotel_id
    AND res_futures.statut = 'CONFIRMEE'
    AND res_futures.date_arrivee > CURRENT_DATE
WHERE h.statut = 'ACTIF'
GROUP BY h.id, h.nom, h.chambres_total, h.chambres_occupees, h.taux_occupation
ORDER BY h.nom;

-- ====================================
-- 4. TESTS D'INTÉGRITÉ RÉFÉRENTIELLE
-- ====================================

-- Test 8: Vérification des clés étrangères
SELECT 
    'Foreign Key Integrity Check' as test_name,
    'rooms.hotel_id -> hotels.id' as relationship,
    COUNT(*) as total_records,
    COUNT(*) - COUNT(h.id) as orphaned_records
FROM public.rooms r
LEFT JOIN public.hotels h ON r.hotel_id = h.id

UNION ALL

SELECT 
    'Foreign Key Integrity Check',
    'reservations.chambre_id -> rooms.id',
    COUNT(*),
    COUNT(*) - COUNT(r.id)
FROM public.reservations res
LEFT JOIN public.rooms r ON res.chambre_id = r.id

UNION ALL

SELECT 
    'Foreign Key Integrity Check',
    'reservations.operateur_id -> operateurs_sociaux.id',
    COUNT(*),
    COUNT(*) - COUNT(op.id)
FROM public.reservations res
LEFT JOIN public.operateurs_sociaux op ON res.operateur_id = op.id
WHERE res.operateur_id IS NOT NULL

UNION ALL

SELECT 
    'Foreign Key Integrity Check',
    'conventions_prix.hotel_id -> hotels.id',
    COUNT(*),
    COUNT(*) - COUNT(h.id)
FROM public.conventions_prix conv
LEFT JOIN public.hotels h ON conv.hotel_id = h.id

UNION ALL

SELECT 
    'Foreign Key Integrity Check',
    'room_categories.hotel_id -> hotels.id',
    COUNT(*),
    COUNT(*) - COUNT(h.id)
FROM public.room_categories rc
LEFT JOIN public.hotels h ON rc.hotel_id = h.id;

-- ====================================
-- 5. TESTS DE CALCULS MÉTIER
-- ====================================

-- Test 9: Calcul du chiffre d'affaires par hôtel
SELECT 
    'Revenue Calculation Test' as test_name,
    h.nom as hotel_name,
    COUNT(res.id) as total_reservations,
    SUM(CASE WHEN res.statut = 'TERMINEE' THEN res.prix * res.duree ELSE 0 END) as completed_revenue,
    SUM(CASE WHEN res.statut = 'EN_COURS' THEN res.prix * (CURRENT_DATE - res.date_arrivee + 1) ELSE 0 END) as current_revenue,
    SUM(CASE WHEN res.statut = 'CONFIRMEE' THEN res.prix * res.duree ELSE 0 END) as projected_revenue
FROM public.hotels h
LEFT JOIN public.reservations res ON h.id = res.hotel_id
WHERE h.statut = 'ACTIF'
GROUP BY h.id, h.nom
ORDER BY completed_revenue DESC;

-- Test 10: Analyse de l'occupation par période
SELECT 
    'Occupancy Analysis' as test_name,
    h.nom as hotel_name,
    DATE_PART('month', res.date_arrivee) as month,
    COUNT(res.id) as reservations_started,
    AVG(res.duree) as average_stay_duration,
    AVG(res.prix) as average_daily_rate
FROM public.hotels h
JOIN public.reservations res ON h.id = res.hotel_id
WHERE res.date_arrivee >= '2024-01-01'
    AND res.statut IN ('TERMINEE', 'EN_COURS')
GROUP BY h.id, h.nom, DATE_PART('month', res.date_arrivee)
ORDER BY h.nom, month;

-- ====================================
-- 6. TESTS DE FONCTIONNALITÉS AVANCÉES
-- ====================================

-- Test 11: Test des conventions de prix actives
SELECT 
    'Active Price Conventions Test' as test_name,
    op.organisation as operator_name,
    h.nom as hotel_name,
    conv.type_chambre,
    conv.prix_standard,
    conv.prix_conventionne,
    conv.reduction,
    CASE 
        WHEN CURRENT_DATE BETWEEN conv.date_debut AND COALESCE(conv.date_fin, '2099-12-31'::DATE)
        THEN 'ACTIVE'
        ELSE 'EXPIRED'
    END as convention_status
FROM public.conventions_prix conv
JOIN public.operateurs_sociaux op ON conv.operateur_id = op.id
JOIN public.hotels h ON conv.hotel_id = h.id
WHERE conv.statut = 'active'
ORDER BY op.organisation, h.nom;

-- Test 12: Test des catégories de chambres et prix
SELECT 
    'Room Categories Pricing Test' as test_name,
    h.nom as hotel_name,
    rc.name as category_name,
    rc.base_price as category_base_price,
    COUNT(r.id) as rooms_in_category,
    AVG(r.prix) as average_room_price,
    MIN(r.prix) as min_price,
    MAX(r.prix) as max_price
FROM public.hotels h
JOIN public.room_categories rc ON h.id = rc.hotel_id
LEFT JOIN public.rooms r ON rc.id = r.category_id
WHERE h.statut = 'ACTIF' AND rc.is_active = true
GROUP BY h.id, h.nom, rc.id, rc.name, rc.base_price
ORDER BY h.nom, rc.display_order;

-- ====================================
-- 7. TESTS DE SÉCURITÉ RLS (Row Level Security)
-- ====================================

-- Test 13: Vérification des politiques RLS
SELECT 
    'RLS Policies Test' as test_name,
    schemaname,
    tablename,
    policyname,
    permissive,
    roles,
    cmd,
    CASE 
        WHEN qual IS NOT NULL THEN 'Has conditions'
        ELSE 'No conditions'
    END as policy_type
FROM pg_policies 
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- Test 14: Test des permissions par rôle (simulation)
SELECT 
    'Role Permissions Test' as test_name,
    tablename,
    COUNT(*) as policy_count,
    array_agg(DISTINCT cmd) as allowed_operations,
    CASE 
        WHEN COUNT(*) >= 2 THEN 'Well protected'
        WHEN COUNT(*) = 1 THEN 'Basic protection'
        ELSE 'No protection'
    END as security_level
FROM pg_policies 
WHERE schemaname = 'public'
GROUP BY tablename
ORDER BY policy_count DESC;

-- ====================================
-- 8. TESTS DE PERFORMANCE ET OPTIMISATION
-- ====================================

-- Test 15: Analyse des index utilisés
SELECT 
    'Index Usage Analysis' as test_name,
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch,
    CASE 
        WHEN idx_tup_read > 0 THEN ROUND((idx_tup_fetch::DECIMAL / idx_tup_read::DECIMAL) * 100, 2)
        ELSE 0
    END as index_efficiency_pct
FROM pg_stat_user_indexes 
WHERE schemaname = 'public'
ORDER BY idx_tup_read DESC;

-- Test 16: Statistiques des tables
SELECT 
    'Table Statistics' as test_name,
    schemaname,
    relname as table_name,
    n_tup_ins as inserts,
    n_tup_upd as updates,
    n_tup_del as deletes,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples,
    CASE 
        WHEN n_live_tup > 0 THEN ROUND((n_dead_tup::DECIMAL / n_live_tup::DECIMAL) * 100, 2)
        ELSE 0
    END as dead_tuple_pct
FROM pg_stat_user_tables 
WHERE schemaname = 'public'
ORDER BY n_live_tup DESC;

-- ====================================
-- 9. FONCTIONS UTILITAIRES POUR LES TESTS
-- ====================================

-- Fonction pour tester la création d'une réservation complète
CREATE OR REPLACE FUNCTION test_create_reservation(
    p_hotel_id BIGINT,
    p_usager_id BIGINT,
    p_operateur_id BIGINT,
    p_date_arrivee DATE,
    p_date_depart DATE
) RETURNS TABLE (
    success BOOLEAN,
    message TEXT,
    reservation_id BIGINT,
    room_assigned TEXT,
    calculated_price DECIMAL
) AS $$
DECLARE
    v_room_id BIGINT;
    v_room_numero TEXT;
    v_prix DECIMAL;
    v_reservation_id BIGINT;
    v_convention_prix DECIMAL;
BEGIN
    -- Chercher une chambre disponible
    SELECT r.id, r.numero, r.prix 
    INTO v_room_id, v_room_numero, v_prix
    FROM public.rooms r
    WHERE r.hotel_id = p_hotel_id
        AND r.statut = 'disponible'
        AND NOT EXISTS (
            SELECT 1 FROM public.reservations res
            WHERE res.chambre_id = r.id
                AND res.statut IN ('CONFIRMEE', 'EN_COURS')
                AND p_date_arrivee <= res.date_depart
                AND p_date_depart >= res.date_arrivee
        )
    ORDER BY r.prix
    LIMIT 1;
    
    IF v_room_id IS NULL THEN
        RETURN QUERY SELECT false, 'Aucune chambre disponible'::TEXT, NULL::BIGINT, NULL::TEXT, NULL::DECIMAL;
        RETURN;
    END IF;
    
    -- Vérifier s'il y a une convention de prix
    SELECT prix_conventionne INTO v_convention_prix
    FROM public.conventions_prix conv
    JOIN public.rooms r ON conv.hotel_id = r.hotel_id
    WHERE conv.operateur_id = p_operateur_id
        AND conv.hotel_id = p_hotel_id
        AND conv.statut = 'active'
        AND p_date_arrivee BETWEEN conv.date_debut AND COALESCE(conv.date_fin, '2099-12-31'::DATE)
        AND r.id = v_room_id
    ORDER BY conv.prix_conventionne
    LIMIT 1;
    
    -- Utiliser le prix conventionné si disponible
    IF v_convention_prix IS NOT NULL THEN
        v_prix := v_convention_prix;
    END IF;
    
    -- Créer la réservation
    INSERT INTO public.reservations (
        usager_id, chambre_id, hotel_id, date_arrivee, date_depart,
        statut, prescripteur, prix, duree, operateur_id
    ) VALUES (
        p_usager_id, v_room_id, p_hotel_id, p_date_arrivee, p_date_depart,
        'CONFIRMEE', 'Test automatique', v_prix, 
        p_date_depart - p_date_arrivee, p_operateur_id
    ) RETURNING id INTO v_reservation_id;
    
    RETURN QUERY SELECT 
        true, 
        'Réservation créée avec succès'::TEXT, 
        v_reservation_id, 
        v_room_numero, 
        v_prix;
END;
$$ LANGUAGE plpgsql;

-- Fonction pour tester les calculs de statistiques
CREATE OR REPLACE FUNCTION test_statistics_calculation(p_hotel_id BIGINT)
RETURNS TABLE (
    hotel_name TEXT,
    total_rooms INTEGER,
    occupied_rooms INTEGER,
    calculated_rate DECIMAL,
    stored_rate DECIMAL,
    rate_match BOOLEAN
) AS $$
DECLARE
    v_total INTEGER;
    v_occupied INTEGER;
    v_calculated DECIMAL;
    v_stored DECIMAL;
    v_hotel_name TEXT;
BEGIN
    SELECT nom INTO v_hotel_name FROM public.hotels WHERE id = p_hotel_id;
    
    SELECT COUNT(*) INTO v_total
    FROM public.rooms WHERE hotel_id = p_hotel_id;
    
    SELECT COUNT(*) INTO v_occupied
    FROM public.rooms WHERE hotel_id = p_hotel_id AND statut = 'occupee';
    
    v_calculated := CASE 
        WHEN v_total > 0 THEN ROUND((v_occupied::DECIMAL / v_total::DECIMAL) * 100, 2)
        ELSE 0 
    END;
    
    SELECT taux_occupation INTO v_stored
    FROM public.hotels WHERE id = p_hotel_id;
    
    RETURN QUERY SELECT 
        v_hotel_name,
        v_total,
        v_occupied,
        v_calculated,
        v_stored,
        ABS(v_calculated - v_stored) < 0.01;
END;
$$ LANGUAGE plpgsql;

-- ====================================
-- 10. SCRIPT D'EXÉCUTION DES TESTS
-- ====================================

DO $$
DECLARE
    test_start TIMESTAMP;
    test_end TIMESTAMP;
    total_duration INTERVAL;
BEGIN
    test_start := NOW();
    
    RAISE NOTICE '====================================';
    RAISE NOTICE 'EXÉCUTION DES TESTS DE RELATIONS';
    RAISE NOTICE 'Début: %', test_start;
    RAISE NOTICE '====================================';
    
    -- Test des statistiques pour chaque hôtel
    RAISE NOTICE '';
    RAISE NOTICE 'Test des calculs de statistiques:';
    RAISE NOTICE '------------------------------------';
    
    FOR i IN 1..4 LOOP
        DECLARE
            test_result RECORD;
        BEGIN
            FOR test_result IN SELECT * FROM test_statistics_calculation(i) LOOP
                RAISE NOTICE 'Hôtel %: Total=%, Occupé=%, Calculé=%%, Stocké=%%, Match=%', 
                    test_result.hotel_name,
                    test_result.total_rooms,
                    test_result.occupied_rooms,
                    test_result.calculated_rate,
                    test_result.stored_rate,
                    test_result.rate_match;
            END LOOP;
        EXCEPTION 
            WHEN OTHERS THEN
                RAISE NOTICE 'Erreur lors du test de l''hôtel %: %', i, SQLERRM;
        END;
    END LOOP;
    
    test_end := NOW();
    total_duration := test_end - test_start;
    
    RAISE NOTICE '';
    RAISE NOTICE '====================================';
    RAISE NOTICE 'TESTS TERMINÉS';
    RAISE NOTICE 'Durée totale: %', total_duration;
    RAISE NOTICE '====================================';
    
END $$;

-- ====================================
-- TESTS DE RELATIONS CRÉÉS AVEC SUCCÈS
-- ====================================

COMMENT ON FUNCTION test_create_reservation(BIGINT, BIGINT, BIGINT, DATE, DATE) IS 'Teste la création complète d''une réservation avec toute la logique métier';
COMMENT ON FUNCTION test_statistics_calculation(BIGINT) IS 'Teste les calculs de statistiques pour un hôtel donné';

-- Vue pour surveiller l'état des relations en temps réel
CREATE OR REPLACE VIEW relations_health_monitor AS
SELECT 
    'Hotels-Rooms' as relation_name,
    h.nom as parent_entity,
    COUNT(r.id) as child_count,
    'OK' as status
FROM public.hotels h
LEFT JOIN public.rooms r ON h.id = r.hotel_id
WHERE h.statut = 'ACTIF'
GROUP BY h.id, h.nom

UNION ALL

SELECT 
    'Rooms-Reservations',
    h.nom || ' - ' || r.numero,
    COUNT(res.id),
    CASE 
        WHEN r.statut = 'occupee' AND COUNT(res.id) FILTER (WHERE res.statut = 'EN_COURS') = 0 
        THEN 'INCONSISTENT'
        ELSE 'OK'
    END
FROM public.hotels h
JOIN public.rooms r ON h.id = r.hotel_id
LEFT JOIN public.reservations res ON r.id = res.chambre_id
GROUP BY h.nom, r.numero, r.statut
ORDER BY status DESC, relation_name;

-- Requête finale de résumé
SELECT 
    'RÉSUMÉ DES TESTS DE RELATIONS' as summary,
    COUNT(DISTINCT h.id) as hotels_tested,
    COUNT(DISTINCT r.id) as rooms_tested,
    COUNT(DISTINCT res.id) as reservations_tested,
    COUNT(DISTINCT op.id) as operators_tested,
    COUNT(DISTINCT conv.id) as conventions_tested
FROM public.hotels h
LEFT JOIN public.rooms r ON h.id = r.hotel_id
LEFT JOIN public.reservations res ON r.id = res.chambre_id
LEFT JOIN public.operateurs_sociaux op ON res.operateur_id = op.id
LEFT JOIN public.conventions_prix conv ON op.id = conv.operateur_id
WHERE h.statut = 'ACTIF';