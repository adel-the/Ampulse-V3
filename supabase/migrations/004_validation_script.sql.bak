-- ====================================
-- SCRIPT DE VALIDATION ET VÉRIFICATION
-- SoliReserve Enhanced - Validation complète de la base de données
-- ====================================

-- ====================================
-- 1. FONCTION DE VALIDATION GÉNÉRALE
-- ====================================

CREATE OR REPLACE FUNCTION validate_database_structure()
RETURNS TABLE (
    check_name TEXT,
    status TEXT,
    message TEXT,
    details JSONB
) AS $$
DECLARE
    table_count INTEGER;
    index_count INTEGER;
    trigger_count INTEGER;
    policy_count INTEGER;
    function_count INTEGER;
BEGIN
    -- Vérification des tables principales
    RETURN QUERY
    SELECT 
        'Tables Existence'::TEXT,
        CASE WHEN COUNT(*) = 16 THEN 'PASS' ELSE 'FAIL' END::TEXT,
        format('Tables trouvées: %s/16', COUNT(*))::TEXT,
        jsonb_agg(table_name ORDER BY table_name)
    FROM information_schema.tables 
    WHERE table_schema = 'public' 
    AND table_type = 'BASE TABLE'
    AND table_name NOT LIKE 'pg_%';

    -- Vérification des index
    SELECT COUNT(*) INTO index_count
    FROM pg_indexes 
    WHERE schemaname = 'public';
    
    RETURN QUERY
    SELECT 
        'Indexes'::TEXT,
        CASE WHEN index_count >= 20 THEN 'PASS' ELSE 'WARN' END::TEXT,
        format('Index créés: %s', index_count)::TEXT,
        to_jsonb(index_count);

    -- Vérification des triggers
    SELECT COUNT(*) INTO trigger_count
    FROM information_schema.triggers 
    WHERE trigger_schema = 'public';
    
    RETURN QUERY
    SELECT 
        'Triggers'::TEXT,
        CASE WHEN trigger_count >= 14 THEN 'PASS' ELSE 'WARN' END::TEXT,
        format('Triggers créés: %s', trigger_count)::TEXT,
        to_jsonb(trigger_count);

    -- Vérification des politiques RLS
    SELECT COUNT(*) INTO policy_count
    FROM pg_policies 
    WHERE schemaname = 'public';
    
    RETURN QUERY
    SELECT 
        'RLS Policies'::TEXT,
        CASE WHEN policy_count >= 30 THEN 'PASS' ELSE 'WARN' END::TEXT,
        format('Politiques RLS créées: %s', policy_count)::TEXT,
        to_jsonb(policy_count);

    -- Vérification des fonctions personnalisées
    SELECT COUNT(*) INTO function_count
    FROM information_schema.routines 
    WHERE routine_schema = 'public' 
    AND routine_type = 'FUNCTION'
    AND routine_name NOT LIKE 'pg_%';
    
    RETURN QUERY
    SELECT 
        'Custom Functions'::TEXT,
        CASE WHEN function_count >= 5 THEN 'PASS' ELSE 'WARN' END::TEXT,
        format('Fonctions personnalisées: %s', function_count)::TEXT,
        to_jsonb(function_count);

END;
$$ LANGUAGE plpgsql;

-- ====================================
-- 2. VALIDATION DES CONTRAINTES
-- ====================================

CREATE OR REPLACE FUNCTION validate_constraints()
RETURNS TABLE (
    constraint_type TEXT,
    table_name TEXT,
    constraint_name TEXT,
    status TEXT,
    details TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tc.constraint_type::TEXT,
        tc.table_name::TEXT,
        tc.constraint_name::TEXT,
        'ACTIVE'::TEXT,
        CASE 
            WHEN tc.constraint_type = 'FOREIGN KEY' THEN 
                format('Référence: %s -> %s', tc.table_name, ccu.table_name)
            WHEN tc.constraint_type = 'UNIQUE' THEN
                'Contrainte d''unicité'
            WHEN tc.constraint_type = 'CHECK' THEN
                'Contrainte de vérification'
            ELSE tc.constraint_type
        END::TEXT
    FROM information_schema.table_constraints tc
    LEFT JOIN information_schema.constraint_column_usage ccu 
        ON tc.constraint_name = ccu.constraint_name
    WHERE tc.table_schema = 'public'
    AND tc.constraint_type IN ('FOREIGN KEY', 'UNIQUE', 'CHECK')
    ORDER BY tc.constraint_type, tc.table_name;
END;
$$ LANGUAGE plpgsql;

-- ====================================
-- 3. VALIDATION DES DONNÉES
-- ====================================

CREATE OR REPLACE FUNCTION validate_data_integrity()
RETURNS TABLE (
    check_name TEXT,
    status TEXT,
    count_result INTEGER,
    message TEXT
) AS $$
DECLARE
    orphan_rooms INTEGER;
    orphan_reservations INTEGER;
    invalid_dates INTEGER;
    inactive_hotels_with_rooms INTEGER;
BEGIN
    -- Vérifier les chambres orphelines
    SELECT COUNT(*) INTO orphan_rooms
    FROM public.rooms r
    LEFT JOIN public.hotels h ON r.hotel_id = h.id
    WHERE h.id IS NULL;
    
    RETURN QUERY
    SELECT 
        'Orphaned Rooms'::TEXT,
        CASE WHEN orphan_rooms = 0 THEN 'PASS' ELSE 'FAIL' END::TEXT,
        orphan_rooms,
        format('Chambres sans hôtel associé: %s', orphan_rooms)::TEXT;

    -- Vérifier les réservations orphelines
    SELECT COUNT(*) INTO orphan_reservations
    FROM public.reservations r
    LEFT JOIN public.rooms rm ON r.chambre_id = rm.id
    WHERE rm.id IS NULL;
    
    RETURN QUERY
    SELECT 
        'Orphaned Reservations'::TEXT,
        CASE WHEN orphan_reservations = 0 THEN 'PASS' ELSE 'FAIL' END::TEXT,
        orphan_reservations,
        format('Réservations sans chambre valide: %s', orphan_reservations)::TEXT;

    -- Vérifier les dates invalides
    SELECT COUNT(*) INTO invalid_dates
    FROM public.reservations
    WHERE date_depart <= date_arrivee;
    
    RETURN QUERY
    SELECT 
        'Invalid Dates'::TEXT,
        CASE WHEN invalid_dates = 0 THEN 'PASS' ELSE 'FAIL' END::TEXT,
        invalid_dates,
        format('Réservations avec dates invalides: %s', invalid_dates)::TEXT;

    -- Vérifier la cohérence des statuts hôtels
    SELECT COUNT(*) INTO inactive_hotels_with_rooms
    FROM public.hotels h
    JOIN public.rooms r ON h.id = r.hotel_id
    WHERE h.statut = 'INACTIF' AND r.statut = 'occupee';
    
    RETURN QUERY
    SELECT 
        'Hotel Status Consistency'::TEXT,
        CASE WHEN inactive_hotels_with_rooms = 0 THEN 'PASS' ELSE 'WARN' END::TEXT,
        inactive_hotels_with_rooms,
        format('Hôtels inactifs avec chambres occupées: %s', inactive_hotels_with_rooms)::TEXT;

END;
$$ LANGUAGE plpgsql;

-- ====================================
-- 4. VALIDATION DES STATISTIQUES
-- ====================================

CREATE OR REPLACE FUNCTION validate_statistics()
RETURNS TABLE (
    metric_name TEXT,
    calculated_value NUMERIC,
    stored_value NUMERIC,
    status TEXT,
    hotel_name TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'Occupation Rate'::TEXT,
        ROUND(
            CASE 
                WHEN COUNT(r.*) > 0 THEN 
                    (COUNT(r.*) FILTER (WHERE r.statut = 'occupee')::DECIMAL / COUNT(r.*)::DECIMAL) * 100
                ELSE 0 
            END, 2
        )::NUMERIC,
        h.taux_occupation::NUMERIC,
        CASE 
            WHEN ABS(
                ROUND(
                    CASE 
                        WHEN COUNT(r.*) > 0 THEN 
                            (COUNT(r.*) FILTER (WHERE r.statut = 'occupee')::DECIMAL / COUNT(r.*)::DECIMAL) * 100
                        ELSE 0 
                    END, 2
                ) - h.taux_occupation
            ) <= 0.01 THEN 'PASS' 
            ELSE 'FAIL' 
        END::TEXT,
        h.nom::TEXT
    FROM public.hotels h
    LEFT JOIN public.rooms r ON h.id = r.hotel_id
    WHERE h.statut = 'ACTIF'
    GROUP BY h.id, h.nom, h.taux_occupation;
END;
$$ LANGUAGE plpgsql;

-- ====================================
-- 5. VALIDATION DES PERMISSIONS RLS
-- ====================================

CREATE OR REPLACE FUNCTION test_rls_policies()
RETURNS TABLE (
    table_name TEXT,
    rls_enabled BOOLEAN,
    policy_count INTEGER,
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.relname::TEXT,
        c.relrowsecurity,
        COUNT(p.policyname)::INTEGER,
        CASE 
            WHEN c.relrowsecurity AND COUNT(p.policyname) > 0 THEN 'PASS'
            WHEN c.relrowsecurity AND COUNT(p.policyname) = 0 THEN 'WARN'
            ELSE 'FAIL'
        END::TEXT
    FROM pg_class c
    LEFT JOIN pg_policies p ON c.relname = p.tablename
    WHERE c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')
    AND c.relkind = 'r'
    AND c.relname NOT LIKE 'pg_%'
    GROUP BY c.relname, c.relrowsecurity
    ORDER BY c.relname;
END;
$$ LANGUAGE plpgsql;

-- ====================================
-- 6. SCRIPT PRINCIPAL D'EXÉCUTION DES TESTS
-- ====================================

DO $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    total_tests INTEGER := 0;
    passed_tests INTEGER := 0;
    failed_tests INTEGER := 0;
    warning_tests INTEGER := 0;
    test_record RECORD;
BEGIN
    start_time := NOW();
    
    RAISE NOTICE '====================================';
    RAISE NOTICE 'DÉBUT DE LA VALIDATION DE LA BASE DE DONNÉES';
    RAISE NOTICE 'Heure de début: %', start_time;
    RAISE NOTICE '====================================';
    
    -- Test 1: Structure de la base de données
    RAISE NOTICE '';
    RAISE NOTICE '1. VALIDATION DE LA STRUCTURE:';
    RAISE NOTICE '------------------------------------';
    
    FOR test_record IN SELECT * FROM validate_database_structure() LOOP
        total_tests := total_tests + 1;
        RAISE NOTICE '% - %: %', test_record.check_name, test_record.status, test_record.message;
        
        CASE test_record.status
            WHEN 'PASS' THEN passed_tests := passed_tests + 1;
            WHEN 'FAIL' THEN failed_tests := failed_tests + 1;
            WHEN 'WARN' THEN warning_tests := warning_tests + 1;
        END CASE;
    END LOOP;
    
    -- Test 2: Contraintes
    RAISE NOTICE '';
    RAISE NOTICE '2. VALIDATION DES CONTRAINTES:';
    RAISE NOTICE '------------------------------------';
    
    SELECT COUNT(*) INTO total_tests FROM validate_constraints();
    RAISE NOTICE 'Contraintes vérifiées: %', (SELECT COUNT(*) FROM validate_constraints());
    passed_tests := passed_tests + 1;
    
    -- Test 3: Intégrité des données
    RAISE NOTICE '';
    RAISE NOTICE '3. VALIDATION DE L''INTÉGRITÉ DES DONNÉES:';
    RAISE NOTICE '------------------------------------';
    
    FOR test_record IN SELECT * FROM validate_data_integrity() LOOP
        total_tests := total_tests + 1;
        RAISE NOTICE '% - %: %', test_record.check_name, test_record.status, test_record.message;
        
        CASE test_record.status
            WHEN 'PASS' THEN passed_tests := passed_tests + 1;
            WHEN 'FAIL' THEN failed_tests := failed_tests + 1;
            WHEN 'WARN' THEN warning_tests := warning_tests + 1;
        END CASE;
    END LOOP;
    
    -- Test 4: Statistiques
    RAISE NOTICE '';
    RAISE NOTICE '4. VALIDATION DES STATISTIQUES:';
    RAISE NOTICE '------------------------------------';
    
    FOR test_record IN SELECT * FROM validate_statistics() LOOP
        total_tests := total_tests + 1;
        RAISE NOTICE 'Hôtel %: Taux calculé = %, Taux stocké = % - %', 
            test_record.hotel_name, 
            test_record.calculated_value, 
            test_record.stored_value, 
            test_record.status;
        
        CASE test_record.status
            WHEN 'PASS' THEN passed_tests := passed_tests + 1;
            WHEN 'FAIL' THEN failed_tests := failed_tests + 1;
            WHEN 'WARN' THEN warning_tests := warning_tests + 1;
        END CASE;
    END LOOP;
    
    -- Test 5: Politiques RLS
    RAISE NOTICE '';
    RAISE NOTICE '5. VALIDATION DES POLITIQUES RLS:';
    RAISE NOTICE '------------------------------------';
    
    FOR test_record IN SELECT * FROM test_rls_policies() LOOP
        total_tests := total_tests + 1;
        RAISE NOTICE 'Table %: RLS=%, Politiques=% - %', 
            test_record.table_name, 
            test_record.rls_enabled, 
            test_record.policy_count, 
            test_record.status;
        
        CASE test_record.status
            WHEN 'PASS' THEN passed_tests := passed_tests + 1;
            WHEN 'FAIL' THEN failed_tests := failed_tests + 1;
            WHEN 'WARN' THEN warning_tests := warning_tests + 1;
        END CASE;
    END LOOP;
    
    end_time := NOW();
    
    -- Résumé final
    RAISE NOTICE '';
    RAISE NOTICE '====================================';
    RAISE NOTICE 'RÉSUMÉ DE LA VALIDATION';
    RAISE NOTICE '====================================';
    RAISE NOTICE 'Durée totale: %', end_time - start_time;
    RAISE NOTICE 'Tests exécutés: %', total_tests;
    RAISE NOTICE 'Tests réussis: % (%.%)', passed_tests, ROUND((passed_tests::DECIMAL/total_tests::DECIMAL)*100, 1);
    RAISE NOTICE 'Avertissements: % (%.%)', warning_tests, ROUND((warning_tests::DECIMAL/total_tests::DECIMAL)*100, 1);
    RAISE NOTICE 'Tests échoués: % (%.%)', failed_tests, ROUND((failed_tests::DECIMAL/total_tests::DECIMAL)*100, 1);
    RAISE NOTICE '';
    
    IF failed_tests = 0 THEN
        RAISE NOTICE '✅ VALIDATION RÉUSSIE - Base de données opérationnelle';
    ELSIF failed_tests <= 2 THEN
        RAISE NOTICE '⚠️  VALIDATION PARTIELLE - Quelques problèmes détectés';
    ELSE
        RAISE NOTICE '❌ VALIDATION ÉCHOUÉE - Problèmes critiques détectés';
    END IF;
    
    RAISE NOTICE '====================================';
    
END $$;

-- ====================================
-- 7. REQUÊTES DE VÉRIFICATION RAPIDE
-- ====================================

-- Vue pour un résumé rapide de l'état de la base
CREATE OR REPLACE VIEW database_health_summary AS
SELECT 
    'Tables' as component,
    COUNT(*)::TEXT as count,
    'Base tables created' as description
FROM information_schema.tables 
WHERE table_schema = 'public' AND table_type = 'BASE TABLE'

UNION ALL

SELECT 
    'Indexes',
    COUNT(*)::TEXT,
    'Database indexes'
FROM pg_indexes 
WHERE schemaname = 'public'

UNION ALL

SELECT 
    'RLS Policies',
    COUNT(*)::TEXT,
    'Row Level Security policies'
FROM pg_policies 
WHERE schemaname = 'public'

UNION ALL

SELECT 
    'Active Hotels',
    COUNT(*)::TEXT,
    'Hotels with ACTIF status'
FROM public.hotels 
WHERE statut = 'ACTIF'

UNION ALL

SELECT 
    'Total Rooms',
    COUNT(*)::TEXT,
    'All rooms in system'
FROM public.rooms

UNION ALL

SELECT 
    'Occupied Rooms',
    COUNT(*)::TEXT,
    'Currently occupied rooms'
FROM public.rooms 
WHERE statut = 'occupee'

UNION ALL

SELECT 
    'Active Reservations',
    COUNT(*)::TEXT,
    'Current active reservations'
FROM public.reservations 
WHERE statut IN ('CONFIRMEE', 'EN_COURS')

UNION ALL

SELECT 
    'Social Operators',
    COUNT(*)::TEXT,
    'Active social operators'
FROM public.operateurs_sociaux 
WHERE statut = 'actif'

UNION ALL

SELECT 
    'Clients',
    COUNT(*)::TEXT,
    'Total clients in database'
FROM public.clients;

-- Fonction pour exporter les résultats de validation
CREATE OR REPLACE FUNCTION export_validation_results()
RETURNS TABLE (
    validation_date TIMESTAMP,
    component TEXT,
    status TEXT,
    details TEXT,
    recommendations TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        NOW() as validation_date,
        'Database Structure' as component,
        CASE WHEN COUNT(*) >= 16 THEN 'HEALTHY' ELSE 'ISSUE' END as status,
        format('Tables: %s, Expected: 16+', COUNT(*)) as details,
        CASE WHEN COUNT(*) < 16 THEN 'Verify all tables are created' ELSE 'No action needed' END as recommendations
    FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
    
    UNION ALL
    
    SELECT 
        NOW(),
        'Data Integrity',
        CASE WHEN COUNT(*) = 0 THEN 'HEALTHY' ELSE 'ISSUE' END,
        format('Orphaned rooms: %s', COUNT(*)),
        CASE WHEN COUNT(*) > 0 THEN 'Fix orphaned room references' ELSE 'No action needed' END
    FROM public.rooms r
    LEFT JOIN public.hotels h ON r.hotel_id = h.id
    WHERE h.id IS NULL;
END;
$$ LANGUAGE plpgsql;

-- ====================================
-- VALIDATION SCRIPT CRÉÉ AVEC SUCCÈS
-- ====================================

COMMENT ON FUNCTION validate_database_structure() IS 'Valide la structure complète de la base de données';
COMMENT ON FUNCTION validate_constraints() IS 'Vérifie toutes les contraintes de la base';
COMMENT ON FUNCTION validate_data_integrity() IS 'Contrôle l''intégrité des données';
COMMENT ON FUNCTION validate_statistics() IS 'Valide la cohérence des statistiques calculées';
COMMENT ON FUNCTION test_rls_policies() IS 'Teste les politiques de sécurité RLS';
COMMENT ON VIEW database_health_summary IS 'Vue résumée de l''état de santé de la base';

-- Exécuter un test rapide
SELECT * FROM database_health_summary ORDER BY component;